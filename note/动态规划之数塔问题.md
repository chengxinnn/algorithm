## 动态规划之数塔问题

问题描述：如下图所示，将一些数字排成塔的形状，其中第1层有1个数字，第2层有2个数字，第n层有n个数字。现在要从第1层走到第n层，每向下一层时只能选择与其连接的两个数字的其中之一。找出一条路径，使得该路径上的数字之和最大。

![Image result for 数塔问题](https://tse4-mm.cn.bing.net/th/id/OIP.12AIdtEKQnRlIVPkjybL3wAAAA?w=273&h=160&c=7&o=5&dpr=1.1&pid=1.7)

### 

分析：

假设现在从 9->12->6 来到了 6，并枚举从 6 出发到达最底层的所有路径。之后，当按 9->15->6 的路线再次来到 6 时，我们显然不希望再进行重复计算，于是，我们想到，当第一次枚举从 6 出发到达最底层的所有路径时，就应该把所获得的最大路径和记录下来，这样当再次访问到数字 6 时，就可以直接获取这个最大值，而不需要再次进行计算。

于是，我们令 `dp[i][j]`  表示第 i 层的第 j 个数字到达最底层的最大路径和，比如 `dp[3][2]` 即表示数字 6 达到最底层的最大路径和。在定义了这个数组之后，显然，`dp[1][1]` 就是第 1 层到达最底层的最大路径和，也就是我们所要求得的解。那么，如何计算出 `dp[1][1]` 呢？

我们发现，对于数塔中的任意一个数字（假设它是第 i 层第 j 个数字，记为 `t(i, j)` ），那么它到最底层的最大路径和仅与 `t(i+1, j)` 和 `t(i+1, j+1)` 这两个数字达到最底层的最大路径和有关，也就是：

```shell
dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + t[i][j]
```

我们把 `dp[i][j]` 称为问题的**状态**，而把上面的式子称为**状态转移方程**，它把状态 `dp[i][j]` 转移为 `dp[i+1][j] 和 dp[i+1][j+1]` ，也就是把第 i 层的状态推到了第 i+1 层的状态，逐层下推，由此也可以很容的想到，状态的**边界**就是到达最底层的时候，数塔最后一层的dp值等于其元素本身，即

```shell
dp[n][j] = t[n][j] (1≤j≤n)
```

我们**把这种能直接确定其结果的部分称为边界，而动态规划的递推写法总是从这些边界出发，并通过状态转移方程扩散至整个dp数组**。

### 递推写法

根据上述的分析，递推写法如下：（注意下标是从0开始的）

```java
public class DigitTower {
    private static int[][] tower = {{9}, {12, 15}, {10, 6, 8}, {2, 18, 9, 5}, {19, 7, 10, 4, 16}};
    public static void main(String[] args) {
        int n = tower.length;
        int[][] dp = new int[n][n];
        // 初始化边界
        for (int j = 0; j < n; j++) {
            dp[n - 1][j] = tower[n - 1][j];
        }
        // 从倒数第2层开始自底向上，递推求解
        for (int i = n - 2; i >= 0; i--) {
            for (int j = 0; j < i + 1; j++) {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i + 1][j + 1]) + tower[i][j];
            }
        }
        System.out.println("answer: " + dp[0][0]);
    }
}
```



### 递归写法

在用递归方法解决数塔问题之前，先从简单的例子开始说起动态规划的递归写法。以斐波那契数列为例，斐波那契数列的定义为F(0)=1, F(1)=1, F(n)=F(n-1)+F(n-2)，很快能按照递归的思想写出如下代码：

```java
int F(int n){
	if(n==0 || n==1) return 1;
	else return F(n-1)+F(n-2);
}
```

但是，我们知道，简单的递归会存在大量的重复计算，其时间复杂度会高达O(2^n)，也就是对任意 n ，都会计算F(n-1) 和 F(n-2) 这两个分支。为此，我们可以开一个一维数组 dp[]，用于保存中间计算结果，dp[n] 记录F(n)的结果，并用dp[n] = -1表示F(n)当前还没有被计算过。于是，改进上述递归代码，变成如下：

```java
int F(int n){
	if(n==0 || n==1) return 1;   //递归边界
	if(dp[n] != -1) return dp[n];//已经计算过，直接返回结果，不再重复计算
	else{
    	dp[n] = F(n-1)+F(n-2);   //计算F(n)，并保存至dp[n]中
    	return dp[n];
	}
}
```



![斐波那契](https://github.com/kkBill/algorithm/blob/master/img/Fibonacci.jpg)









```java
public class DigitTower {
    private static int[][] tower = {{9}, {12, 15}, {10, 6, 8}, {2, 18, 9, 5}, {19, 7, 10, 4, 16}};
    static int n = tower.length;
    static int[][] dp = new int[n][n];

    // 动态规划的递归写法
    private static int process(int i, int j) {
        if (i == n - 1) return tower[i][j]; // 边界，到达最后一层
        if (dp[i][j] != -1) return dp[i][j];
        else {
            dp[i][j] = Math.max(process(i + 1,j), process(i + 1,j + 1))+ tower[i][j];
            return dp[i][j];
        }
    }

    public static void main(String[] args) {
        // 先标记数组
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], -1);
        }
        System.out.println("answer: " + process(0,0));
    }
}
```



