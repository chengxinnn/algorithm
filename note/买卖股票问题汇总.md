## 买卖股票问题汇总

（注：本文**非原创**，翻译自[这里](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems)， 加上部分自己的理解）

本文对LeetCode中的**买卖股票问题**做了一个汇总。

* ###### [121. Best Time to Buy and Sell Stock](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

* ###### [122. Best Time to Buy and Sell Stock II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

* ###### [123. Best Time to Buy and Sell Stock III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

* ###### [188. Best Time to Buy and Sell Stock IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

* ###### [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

* ###### [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

针对每一个问题，都可以找到非常优秀的题解，但是绝大多题解并没有找到这几个题目之间的联系，在这里，作者试图找到一个通用的解法来解决所有“买卖股票”的问题。大家可以先理解本文的所讲的通用解法，再回看各个独立的题解，应该会有“会当凌绝顶”之感。

### 1 通用框架

买卖股票问题总的来说是这样的：

> 给定一组整数序列代表每一天股票的价格，我们该如何决定买入/卖出以达到利润的最大化？

首先，我们令`prices`表示股票价格数组，下标为`i`（其中`i∈[0,n-1]`），`k`表示题目允许的最大交易次数，**`dp[i][k]`表示在第 i 天结束后完成至多 k 笔交易可获得的最大收益**。那么，最终结果显然就是`dp[n-1][k]`，而存在边界情况：`dp[-1][k] = 0, dp[i][0] = 0`。其中`dp[-1][k] = 0`表示不存在股票数组（下标为 -1只是为了方便理解，实际coding时自有细节处理），而`dp[i][0] = 0`表示不允许交易，这两种情况收益均为 0 ，这是很容易理解的。

为了求出`dp[i][k]`，我们就会考虑其子问题，比如`dp[i-1][k], dp[i][k-1], dp[i-1][k-1], ...`，那么我们该如何找到动态规划的状态转移方程呢？

很自然，我们首先应该考虑第 i 天会采取的动作。在第 i 天，我们可能“**买入(buy)**”，也可能“**卖出(sell)**”，还可能“**什么都不做(rest)**”，我们要做的，就是比较这3种动作中哪一个能带来更大的收益，我们就执行哪一个。但是，由于题目中有说明“不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）”，因此，如果在第 i 天决定买入股票，就必须保证在买入之前并不持有股票；反之，如果要在第 i 天卖出股票，就必须保证在卖出之前持有 1 支股票。基于此，我们可以把状态`dp[i][k]`分解成两类：`dp[i][k][0]`和`dp[i][k][1]`，其中`dp[i][k][0]` 表示在第 i 天结束后（指在执行完buy/sell/rest交易动作之后），完成至多 k 笔交易可获得的最大交易，并且此时手里不再持有股票；而`dp[i][k][1]` 表示在第 i 天结束后（指在执行完buy/sell/rest交易动作之后），完成至多 k 笔交易可获得的最大交易，并且此时手里持有股票。

对于状态`dp[i][k][0]`，在第 i 天，我们可以执行的动作有：

* 什么都不做（也就是说，在第 i 天获得的最大收益和前 i-1 天的最大收益一致）；
* 卖出股票（也就是说，在第 i 天获得的最大收益等于前 i-1 天的最大收益加上今天卖股票的收入）

对于状态`dp[i][k][1]`，在第 i 天，我们可以执行的动作有：

* 什么都不做（也就是说，在第 i 天获得的最大收益和前 i-1 天的最大收益一致）；
* 买入股票（也就是说，在第 i 天获得的最大收益等于前 i-1 天的最大收益减去今天买股票的支出）

此外，需要注意的是，我们知道一次交易必须有买入和卖出，这两者必须是成对的。我们定义在买入的时候改变交易次数变量k。

根据上面的分析，可以写出边界和状态转移方程如下：

```
边界情况：
dp[-1][k][0] = 0         //股票数组都不存在，且不持有股票，收益为0
dp[-1][k][1] = -Infinity //股票数组都不存在，但持有股票，这种情况压根不可能，因此用-∞表示
dp[i][0][0]  = 0         //股票数组存在，但不允许交易，收益为0
dp[i][0][1]  = -Infinity //股票数组存在，但不允许交易，与此同时又持有股票，这种情况压根不可能，同上

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

为了找到最大收益，我们只需要遍历prices数组并更新`dp[i][k][0]`和`dp[i][k][1]`，并且，最终答案一定是`dp[n-1][k][0]`，因为把所有股票都卖出去了总是比到最后还持有股票能获得更大的价值。



### 2 具体应用

下面根据上面的分析，根据不同的题目写出相应的代码。

#### 2.1 case 1: k = 1

在121题中，最多只允许完成一笔交易，即 k = 1。那么根据上面的分析，我们可以写出如下状态转移方程：

```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i])
```

其中，我们知道边界`dp[i][0][0] = 0`，并且`dp[][][]`数组的第2维在本题事实上用不到，因此，我们可以写成2维的，状态转移方程也可以写为：

```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

最后的代码如下：

```java
public int maxProfit(int[] prices) {
	if(prices.length == 0) return 0;

  	int[][] dp = new int[prices.length][2];
  	for(int i = 0; i < prices.length; i++){
    	// 处理边界情况
    	if(i == 0){
      	//dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
     	//dp[i][0] = Math.max(dp[-1][0], dp[-1][1] + prices[0]) = max(0, -INF + prices[i]) = 0
      		dp[i][0] = 0;
      	//dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
      	//dp[i][1] = Math.max(dp[-1][1], -prices[i]) = max(-INF, -prices[0]) = -prices[0]
      		dp[i][1] = -prices[0];
      		continue;
    	}
    	dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    	dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
  	}
  	return dp[prices.length-1][0];
}
```

通过观察，可以看到第 i 天的状态只与第 i-1 天的状态有关，因此可以进一步压缩空间，使空间复杂度变为O(1)。代码如下：

```java
public int maxProfit(int[] prices) {
	int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
     for(int price : prices){
         dp_i_0 = Math.max(dp_i_0, dp_i_1 + price);
         dp_i_1 = Math.max(dp_i_1, -price);//因为价格总是整数，这一步会挑选出截至目前为止的最低价格
     }
     return dp_i_0;
}
```

最后这个精简的代码如果直接看，想必是很难看懂的~（至此，请务必根据一开始所讲解的状态转移过程来理解一遍这个代码！）

**其他解法1**

下面这个解法，是这样分析的：

假设当前在第 i 天，令 minPrice 表示前 i-1 天的最低价格；令 maxProfit 表示前 i-1 天的最大收益。那么考虑第 i 天的收益时，存在两种情况：

- 在第 i 天卖出。很显然，想要获得最大收益，应该在前 i-1 天中价格最低的时候买入，即此时的收益为：prices[i] - minPrice。（可能会出现负数，但是没关系）
- 不在第 i 天卖出。那么第 i 天的最大收益就等于前 i -1 天中的最大收益

状态转移方程为：第 i 天最大收益 = max( 在第 i 天卖出的所得收益 , 前 i-1 天的最大收益)

```java
public int maxProfit(int[] prices) {
     int maxProfit = 0, minPrice = Integer.MAX_VALUE;
     for (int i = 0; i < prices.length; i++) {
         minPrice = Math.min(minPrice, prices[i]);
         maxProfit = Math.max(maxProfit, prices[i] - minPrice);
     }
     return maxProfit;
}
```

仔细对比这种解法和之前根据框架写出来的解法，可以发现，本质上是一样的，只不过我们对代码的解释从不同角度切入罢了。



**其他解法2**

这个解法是从原文作者的链接中找到的解法，该解法使用了[kadane's algorithm ，可以做个了解。](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane's_algorithm)

```

```





